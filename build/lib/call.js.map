{"version":3,"sources":["call.ts"],"names":[],"mappings":"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","file":"call.js","sourcesContent":["import ts = require('typescript');\nimport base = require('./base');\nimport ts2dart = require('./main');\nimport {FacadeConverter} from './facade_converter';\n\nexport default class CallTranspiler extends base.TranspilerBase {\n  constructor(tr: ts2dart.Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.Block:\n        // This is a bit ugly: to separate Declarations from Calls, this code has to special case\n        // blocks that are actually constructor bodies.\n        if (node.parent && node.parent.kind === ts.SyntaxKind.Constructor) {\n          return this.visitConstructorBody(<ts.ConstructorDeclaration>node.parent);\n        }\n        return false;\n      case ts.SyntaxKind.NewExpression:\n        let newExpr = <ts.NewExpression>node;\n        if (this.hasAncestor(node, ts.SyntaxKind.Decorator)) {\n          // Constructor calls in annotations must be const constructor calls.\n          this.emit('const');\n        } else if (this.fc.isInsideConstExpr(node)) {\n          this.emit('const');\n        } else {\n          // Some implementations can replace the `new` keyword.\n          if (this.fc.shouldEmitNew(newExpr)) {\n            this.emit('new');\n          }\n        }\n        if (this.fc.maybeHandleCall(newExpr)) break;\n        this.visitCall(newExpr);\n        break;\n      case ts.SyntaxKind.CallExpression:\n        let callExpr = <ts.CallExpression>node;\n        if (this.fc.maybeHandleCall(callExpr)) break;\n        if (this.maybeHandleSuperCall(callExpr)) break;\n        this.visitCall(callExpr);\n        break;\n      case ts.SyntaxKind.SuperKeyword:\n        this.emit('super');\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  private visitCall(c: ts.CallExpression) {\n    if (c.expression.kind === ts.SyntaxKind.Identifier) {\n      this.fc.visitTypeName(<ts.Identifier>c.expression);\n    } else {\n      this.visit(c.expression);\n    }\n    if (c.typeArguments) {\n      // For DDC, emit generic method arguments in /* block comments */\n      // NB: Surprisingly, whitespace within the comment is significant here :-(\n      // TODO(martinprobst): Remove once Dart natively supports generic methods.\n      if (c.kind !== ts.SyntaxKind.NewExpression) this.emit('/*');\n      this.maybeVisitTypeArguments(c);\n      if (c.kind !== ts.SyntaxKind.NewExpression) this.emitNoSpace('*/');\n    }\n    this.emit('(');\n    if (c.arguments && !this.handleNamedParamsCall(c)) {\n      if ((<any>c).expression.text == 'RegExp') {\n        if (c.arguments.length > 1) {\n          if ((<any>c.arguments[1]).text == 'i') {\n            this.visit(c.arguments[0]);\n            this.emit(', caseSensitive: false)');\n            return;\n          }\n        }\n      } else {\n        this.visitList(c.arguments);\n      }\n    }\n    this.emit(')');\n  }\n\n  private handleNamedParamsCall(c: ts.CallExpression): boolean {\n    // Preamble: This is all committed in the name of backwards compat with the traceur transpiler.\n\n    // Terrible hack: transform foo(a, b, {c: d}) into foo(a, b, c: d), which is Dart's calling\n    // syntax for named/optional parameters. An alternative would be to transform the method\n    // declaration to take a plain object literal and destructure in the method, but then client\n    // code written against Dart wouldn't get nice named parameters.\n    if (c.arguments.length === 0) return false;\n    let last = c.arguments[c.arguments.length - 1];\n    if (last.kind !== ts.SyntaxKind.ObjectLiteralExpression) return false;\n    let objLit = <ts.ObjectLiteralExpression>last;\n    if (objLit.properties.length === 0) return false;\n    // Even worse: foo(a, b, {'c': d}) is considered to *not* be a named parameters call.\n    let hasNonPropAssignments = objLit.properties.some(\n        (p) =>\n            (p.kind !== ts.SyntaxKind.PropertyAssignment ||\n             (<ts.PropertyAssignment>p).name.kind !== ts.SyntaxKind.Identifier));\n    if (hasNonPropAssignments) return false;\n\n    let len = c.arguments.length - 1;\n    this.visitList(c.arguments.slice(0, len));\n    if (len) this.emit(',');\n    let props = objLit.properties;\n    for (let i = 0; i < props.length; i++) {\n      let prop = <ts.PropertyAssignment>props[i];\n      this.emit(base.ident(prop.name));\n      this.emit(':');\n      this.visit(prop.initializer);\n      if (i < objLit.properties.length - 1) this.emit(',');\n    }\n    return true;\n  }\n\n  /**\n   * Handles constructor initializer lists and bodies.\n   *\n   * <p>Dart's super() ctor calls have to be moved to the constructors initializer list, and `const`\n   * constructors must be completely empty, only assigning into fields through the initializer list.\n   * The code below finds super() calls and handles const constructors, marked with the special\n   * `@CONST` annotation on the class.\n   *\n   * <p>Not emitting super() calls when traversing the ctor body is handled by maybeHandleSuperCall\n   * below.\n   */\n  private visitConstructorBody(ctor: ts.ConstructorDeclaration): boolean {\n    let body = ctor.body;\n    if (!body) return false;\n\n    let errorAssignmentsSuper = 'const constructors can only contain assignments and super calls';\n    let errorThisAssignment = 'assignments in const constructors must assign into this.';\n\n    let parent = <base.ClassLike>ctor.parent;\n    let parentIsConst = this.fc.isConstClass(parent);\n    let superCall: ts.CallExpression;\n    let expressions: ts.Expression[] = [];\n    // Find super() calls and (if in a const ctor) collect assignment expressions (not statements!)\n    body.statements.forEach((stmt) => {\n      if (stmt.kind !== ts.SyntaxKind.ExpressionStatement) {\n        if (parentIsConst) this.reportError(stmt, errorAssignmentsSuper);\n        return;\n      }\n      let nestedExpr = (<ts.ExpressionStatement>stmt).expression;\n\n      // super() call?\n      if (nestedExpr.kind === ts.SyntaxKind.CallExpression) {\n        let callExpr = <ts.CallExpression>nestedExpr;\n        if (callExpr.expression.kind !== ts.SyntaxKind.SuperKeyword) {\n          if (parentIsConst) this.reportError(stmt, errorAssignmentsSuper);\n          return;\n        }\n        superCall = callExpr;\n        return;\n      }\n\n      // this.x assignment?\n      if (parentIsConst) {\n        // Check for assignment.\n        if (nestedExpr.kind !== ts.SyntaxKind.BinaryExpression) {\n          this.reportError(nestedExpr, errorAssignmentsSuper);\n          return;\n        }\n        let binExpr = <ts.BinaryExpression>nestedExpr;\n        if (binExpr.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {\n          this.reportError(binExpr, errorAssignmentsSuper);\n          return;\n        }\n        // Check for 'this.'\n        if (binExpr.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {\n          this.reportError(binExpr, errorThisAssignment);\n          return;\n        }\n        let lhs = <ts.PropertyAccessExpression>binExpr.left;\n        if (lhs.expression.kind !== ts.SyntaxKind.ThisKeyword) {\n          this.reportError(binExpr, errorThisAssignment);\n          return;\n        }\n        let ident = lhs.name;\n        binExpr.left = ident;\n        expressions.push(nestedExpr);\n      }\n    });\n\n    let hasInitializerExpr = expressions.length > 0;\n    if (hasInitializerExpr) {\n      // Write out the assignments.\n      this.emit(':');\n      this.visitList(expressions);\n    }\n    if (superCall) {\n      this.emit(hasInitializerExpr ? ',' : ':');\n      this.emit('super (');\n      if (!this.handleNamedParamsCall(superCall)) {\n        this.visitList(superCall.arguments);\n      }\n      this.emit(')');\n    }\n    if (parentIsConst) {\n      // Const ctors don't have bodies.\n      this.emit(';');\n      return true;  // completely handled.\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Checks whether `callExpr` is a super() call that should be ignored because it was already\n   * handled by `maybeEmitSuperInitializer` above.\n   */\n  private maybeHandleSuperCall(callExpr: ts.CallExpression): boolean {\n    if (callExpr.expression.kind !== ts.SyntaxKind.SuperKeyword) return false;\n    // Sanity check that there was indeed a ctor directly above this call.\n    let exprStmt = callExpr.parent;\n    let ctorBody = exprStmt.parent;\n    let ctor = ctorBody.parent;\n    if (ctor.kind !== ts.SyntaxKind.Constructor) {\n      this.reportError(callExpr, 'super calls must be immediate children of their constructors');\n      return false;\n    }\n    this.emit('/* super call moved to initializer */');\n    return true;\n  }\n}\n"]}