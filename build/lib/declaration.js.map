{"version":3,"sources":["declaration.ts"],"names":[],"mappings":";;;;;;AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,IAAY,IAAI,WAAM,QAAQ,CAAC,CAAA;AAI/B;IAAmD,yCAAmB;IACpE,+BACI,EAAc,EAAU,EAAmB,EAAU,4BAAqC;QAC5F,kBAAM,EAAE,CAAC,CAAC;QADgB,OAAE,GAAF,EAAE,CAAiB;QAAU,iCAA4B,GAA5B,4BAA4B,CAAS;IAE9F,CAAC;IAED,yCAAS,GAAT,UAAU,IAAa;QACrB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,KAAK,EAAE,CAAC,UAAU,CAAC,uBAAuB;gBACxC,sEAAsE;gBACtE,IAAI,WAAW,GAA+B,IAAI,CAAC;gBACnD,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;gBACzC,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;gBACpC,IAAI,OAAO,GAA2B,IAAI,CAAC;gBAC3C,IAAI,CAAC,4BAA4B,CAAC,OAAO,CAAC,CAAC;gBAC3C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACzB,EAAE,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC;oBACxB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACf,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gBAClC,CAAC;gBACD,KAAK,CAAC;YAER,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB;gBACjC,IAAI,SAAS,GAAwB,IAAI,CAAC;gBAC1C,EAAE,CAAC,CAAC,SAAS,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;oBAC/E,IAAI,CAAC,cAAc,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;gBACnD,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBAC1C,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB;gBACrC,IAAI,MAAM,GAA4B,IAAI,CAAC;gBAC3C,oEAAoE;gBACpE,8CAA8C;gBAC9C,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;oBAC1F,IAAI,QAAM,GAAgC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC5D,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAM,EAAE,MAAM,CAAC,cAAc,CAAC,CAAC;gBACtF,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,cAAc,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;gBAChD,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;gBAC/B,IAAI,cAAc,GAAsB,IAAI,CAAC;gBAC7C,EAAE,CAAC,CAAC,cAAc,CAAC,KAAK,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;oBACrD,cAAc,CAAC,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;oBACtE,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACvB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC1B,CAAC;gBACD,gDAAgD;gBAChD,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;gBACrC,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,2BAA2B;gBAC5C,IAAI,gBAAgB,GAAmC,IAAI,CAAC;gBAC5D,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBACxC,IAAI,CAAC,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;gBAC/C,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe;gBAChC,IAAI,IAAI,GAAuB,IAAI,CAAC;gBACpC,qDAAqD;gBACrD,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAC5E,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;oBACZ,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,+BAA+B,CAAC,CAAC;gBAC1D,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAClB,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,+BAA+B;gBAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC9B,uBAAuB;oBACvB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,+BAA+B,CAAC,CAAC;gBAC1D,CAAC;gBACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC7B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU;gBAC3B,IAAI,MAAM,GAAkB,IAAI,CAAC;gBACjC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACxB,EAAE,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,qCAAqC,CAAC,CAAC;gBAChE,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;gBAC5B,IAAI,QAAQ,GAA8B,IAAI,CAAC;gBAC/C,8BAA8B;gBAC9B,IAAI,SAAS,SAAe,CAAC;gBAC7B,GAAG,CAAC,CAAC,IAAI,QAAM,GAAG,QAAQ,CAAC,MAAM,EAAE,QAAM,EAAE,QAAM,GAAG,QAAM,CAAC,MAAM,EAAE,CAAC;oBAClE,EAAE,CAAC,CAAC,QAAM,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBACnD,SAAS,GAAyB,QAAO,CAAC,IAAI,CAAC;wBAC/C,KAAK,CAAC;oBACR,CAAC;gBACH,CAAC;gBACD,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;oBAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,8BAA8B,CAAC,CAAC;gBAC3E,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC;gBACxC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAiB,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBAC1D,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACrB,CAAC;gBACD,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACtB,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC1C,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC1B,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;gBACpC,IAAI,CAAC,aAAa,CAAyB,IAAI,CAAC,CAAC;gBACjD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,qBAAqB;gBACtC,0CAA0C;gBAC1C,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;gBAClC,IAAI,CAAC,wBAAwB,CAAuB,IAAI,CAAC,CAAC;gBAC1D,IAAI,CAAC,iBAAiB,CAAuB,IAAI,CAAC,CAAC;gBACnD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;gBAC5B,IAAI,CAAC,wBAAwB,CAAuB,IAAI,CAAC,CAAC;gBAC1D,IAAI,CAAC,iBAAiB,CAAyB,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC5D,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW;gBAC5B,IAAI,CAAC,wBAAwB,CAAuB,IAAI,CAAC,CAAC;gBAC1D,IAAI,CAAC,iBAAiB,CAAyB,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC5D,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,mBAAmB;gBACpC,IAAI,QAAQ,GAA2B,IAAI,CAAC;gBAC5C,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC1C,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBACjC,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa;gBAC9B,IAAI,SAAS,GAA0B,IAAI,CAAC;gBAC5C,iEAAiE;gBACjE,oEAAoE;gBACpE,8BAA8B;gBAC9B,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;oBAChD,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;gBACpC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;oBAC3C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,kBAAkB;gBACnC,IAAI,QAAQ,GAA0B,IAAI,CAAC;gBAC3C,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBACjC,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,iBAAiB;gBAClC,IAAI,OAAO,GAA2B,IAAI,CAAC;gBAC3C,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;gBAC5B,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe;gBAChC,IAAI,mBAAmB,GAA+B,IAAI,CAAC;gBAC3D,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;gBACvD,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC;gBAC5C,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,SAAS;gBAC1B,IAAI,SAAS,GAA4B,IAAI,CAAC;gBAC9C,6EAA6E;gBAC7E,gEAAgE;gBAChE,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC;oBACtD,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC;oBACvD,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBAC9D,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;oBACzC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACpB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBAC3B,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;wBAC1B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;wBACf,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;oBACpC,CAAC;oBACD,KAAK,CAAC;gBACR,CAAC;gBACD,EAAE,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC;oBAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,iCAAiC,CAAC,CAAC;gBACxF,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;oBAC/D,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACpC,KAAK,CAAC;gBACR,CAAC;gBACD,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;gBAE3C,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC;oBACzE,0DAA0D;oBAC1D,IAAI,MAAM,GAAqC,SAAS,CAAC,IAAI,CAAC;oBAC9D,IAAI,gBAAgB,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,cAAc,EAAlB,CAAkB,CAAC,CAAC;oBACvE,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBACrB,gFAAgF;wBAChF,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBACtB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBAC7B,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;wBACxB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;wBAC3B,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;oBAC1C,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC;wBAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBAC/C,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;gBACD,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC1B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACf,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;gBACpC,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa;gBAC9B,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACpB,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe;gBAChC,uDAAuD;gBACvD,wCAAwC;gBACxC,+EAA+E;gBAC/E,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;gBAC7B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;gBAC3B,wDAAwD;gBACxD,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa;gBAC5B,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC1B,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB;gBAC/B,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;gBAC3B,KAAK,CAAC;YACV,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe;gBAChC,+CAA+C;gBAC/C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACnB,IAAI,CAAC,KAAK,CAAO,IAAK,CAAC,UAAU,CAAC,CAAC;gBACnC,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY;gBACvB,IAAK,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC3B,KAAK,CAAC;YACR,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB;gBACnC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAChB,IAAM,CAAC,GAAQ,IAAI,CAAC;gBACpB,IAAI,KAAK,GAAY,IAAI,CAAC;gBAC1B,GAAG,CAAC,CAAU,UAAU,EAAV,KAAA,CAAC,CAAC,QAAQ,EAAV,cAAU,EAAV,IAAU,CAAC;oBAApB,IAAI,CAAC,SAAA;oBACN,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;wBACT,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACnB,CAAC;oBACD,KAAK,GAAG,KAAK,CAAC;oBACd,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC1B;gBACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAChB,KAAK,CAAC;YAGV;gBACE,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAEO,4DAA4B,GAApC,UAAqC,OAA+B;QAClE;;;;;;;;;WASG;QACH,IAAI,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,GAAG,GAAG,2EAA2E,CAAC;QACtF,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC/D,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC;YACnC,sFAAsF;YACtF,4FAA4F;YAC5F,qDAAqD;YACrD,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa;gBAC9D,OAAO,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc;gBACzD,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAC/C,CAAC;QACD,EAAE,CAAC,CAAC,SAAS,KAAK,OAAO,CAAC,CAAC,CAAC;YAC1B,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACZ,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACnB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;oBAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACjC,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClD,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACjC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC3B,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;QACjC,CAAC;IACH,CAAC;IAEO,iDAAiB,GAAzB,UAA0B,EAA8B,EAAE,QAAiB;QACzE,IAAI,CAAC,EAAE,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;QACnC,IAAI,CAAC;YACH,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;gBACZ,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,aAAa;oBACvC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC,CAAC;oBACjD,gFAAgF;oBAChF,2CAA2C;oBAC3C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;oBACpB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAClB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;YACD,EAAE,CAAC,CAAC,QAAQ,CAAC;gBAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC;gBAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YACjC,EAAE,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACjB,yFAAyF;gBACzF,2BAA2B;gBAC3B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,EAAlB,CAAkB,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBACrE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACnB,CAAC;YACD,uEAAuE;YACvE,EAAE,CAAC,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;gBACvB,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC;YACtC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,EAAE,CAAC,UAAU,IAAI,EAAE,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC9C,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,qCAAqC,CAAC,CAAC;gBAC9D,CAAC;YACH,CAAC;YACD,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;gBACZ,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YACtB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACjB,CAAC;QACH,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,EAAE,CAAC,qBAAqB,CAAC,EAAE,CAAC,CAAC;QACpC,CAAC;IACH,CAAC;IAEO,+CAAe,GAAvB,UAAwB,UAAqC;QAC3D,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACf,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,GAAG,CAAC,CAAC,EAAE,iBAAiB,GAAG,UAAU,CAAC,MAAM,EAAE,iBAAiB,EAAE,EAAE,CAAC;YAClE,gEAAgE;YAChE,IAAI,KAAK,GACL,UAAU,CAAC,iBAAiB,CAAC,CAAC,WAAW,IAAI,UAAU,CAAC,iBAAiB,CAAC,CAAC,aAAa,CAAC;YAC7F,EAAE,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBAC5F,KAAK,CAAC;YACR,CAAC;QACH,CAAC;QAED,EAAE,CAAC,CAAC,iBAAiB,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAC;YAC5D,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;QACjC,CAAC;QAED,EAAE,CAAC,CAAC,iBAAiB,KAAK,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,iBAAiB,KAAK,CAAC,CAAC;gBAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC5C,IAAI,kBAAkB,GAAG,UAAU,CAAC,KAAK,CAAC,iBAAiB,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;YAChF,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjB,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACf,EAAE,CAAC,CAAO,IAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACb,IAAK,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC;QACjC,CAAC;IACH,CAAC;IAED;;;;OAIG;IACK,6CAAa,GAArB,UAAsB,IAAoD,EAAE,WAAmB;QAAnB,2BAAmB,GAAnB,mBAAmB;QAC7F,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC;YAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;QACtD,IAAI,eAAe,GAAmB,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;QACvF,IAAI,YAAY,GACZ,IAAI,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAClF,IAAI,YAAY,GAAG,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;QACzD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YACjB,sBAAsB;YACtB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC;QACH,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACd,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YAC1C,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;QACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YACrC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC/B,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjB,CAAC;IAEO,8CAAc,GAAtB,UAAuB,OAAe,EAAE,IAAoB;QAA5D,iBAqCC;QApCC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACtC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACnB,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjC,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACpC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC9C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEf,qEAAqE;QACrE,IAAI,uBAAuB,GAAG,UAAC,KAA8B;YAC3D,EAAE,CAAC,CAAC,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC;gBAClD,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC;gBACnD,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBAC1D,4DAA4D;gBAC5D,KAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAClC,CAAC;QACH,CAAC,CAAC;QAC6B,IAAI,CAAC,OAAQ;aACvC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,EAApC,CAAoC,CAAC;aACnD,OAAO,CACJ,UAAC,IAAI;YACD,OAA4B,IAAK,CAAC,UAAU,CAAC,OAAO,CAAC,uBAAuB,CAAC;QAA7E,CAA6E,CAAC,CAAC;QAC3F,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEtC,+DAA+D;QAC/D,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC;YAC1B,CAAgC,IAAI,CAAC,OAAQ;iBACvC,IAAI,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,WAAW,EAApC,CAAoC,CAAC,CAAC,CAAC,CAAC;YAC5D,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACnB,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACjC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjB,CAAC;IAEO,+CAAe,GAAvB,UAAwB,UAAsC;QAA9D,iBAmBC;QAlBC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;YAAC,MAAM,CAAC;QAExB,UAAU,CAAC,OAAO,CAAC,UAAC,CAAC;YACnB,sBAAsB;YACtB,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;YACpC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC;gBAChE,kBAAkB;gBAClB,IAAI,QAAQ,GAAuB,CAAC,CAAC,UAAW,CAAC;gBACjD,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACzC,CAAC;YACD,mDAAmD;YACnD,EAAE,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,CAAC;gBACrB,yDAAyD;gBACzD,MAAM,CAAC;YACT,CAAC;YACD,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACf,KAAI,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,wDAAwB,GAAhC,UAAiC,IAAoB;QACnD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACtC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAExC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACzD,oEAAoE;YACpE,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,4BAA4B,CAAC;YAAC,MAAM,CAAC;QAC/C,0EAA0E;QAC1E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;YAAC,MAAM,CAAC;QACvB,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YAAC,MAAM,CAAC;QAClB,IAAI,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACnE,IAAI,cAAc,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACxC,EAAE,CAAC,CAAC,SAAS,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,2CAA2C,CAAC,CAAC;QACtE,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,cAAc,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,8CAA8C,CAAC,CAAC;QACzE,CAAC;IACH,CAAC;IAEO,mDAAmB,GAA3B,UAA4B,SAAkC;QAC5D,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAC3C,IAAI,EAAE,GAAsB,SAAS,CAAC,IAAI,CAAC;QAC3C,IAAI,aAAa,GAAG,IAAI,CAAC,EAAE,CAAC,oBAAoB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACjE,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QAC9C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACf,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5C,IAAI,IAAI,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC;gBAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YACzD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtB,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvD,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,iDAAiD,CAAC,CAAC;YAC5E,CAAC;YACD,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACT,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACnB,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC;gBAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjD,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjB,CAAC;IAEO,+CAAe,GAAvB,UAAwB,SAAkC;QACxD,IAAI,GAAG,GAA0B,EAAE,CAAC;QACpC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC;YAAC,MAAM,CAAC,GAAG,CAAC;QACvC,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,uBAAuB,CAAC,CAAC,CAAC;YACzE,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,2DAA2D,CAAC,CAAC;YACzF,MAAM,CAAC,GAAG,CAAC;QACb,CAAC;QACD,GAAG,CAAC,CAAU,UAA8D,EAA9D,KAA6B,SAAS,CAAC,WAAY,CAAC,UAAU,EAA9D,cAA8D,EAA9D,IAA8D,CAAC;YAAxE,IAAI,CAAC,SAAA;YACR,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC,CAAC;gBAChD,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,uDAAuD,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;gBACtF,QAAQ,CAAC;YACX,CAAC;YACD,IAAI,GAAG,GAA0B,CAAC,CAAC;YACnC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,WAAW,CAAC;SAC7C;QACD,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED;;;OAGG;IACK,6DAA6B,GAArC,UACI,IAAY,EAAE,SAAsC,EACpD,cAAyD;QAC3D,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACrB,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;YACnB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChB,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;YACnB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;YAC/B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjB,CAAC;IACH,4BAAC;AAAD,CAvhBA,AAuhBC,CAvhBkD,IAAI,CAAC,cAAc,GAuhBrE;AAvhBD;0CAuhBC,CAAA","file":"declaration.js","sourcesContent":["import * as ts from 'typescript';\n\nimport * as base from './base';\nimport {FacadeConverter} from './facade_converter';\nimport {Transpiler} from './main';\n\nexport default class DeclarationTranspiler extends base.TranspilerBase {\n  constructor(\n      tr: Transpiler, private fc: FacadeConverter, private enforceUnderscoreConventions: boolean) {\n    super(tr);\n  }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.VariableDeclarationList:\n        // Note: VariableDeclarationList can only occur as part of a for loop.\n        let varDeclList = <ts.VariableDeclarationList>node;\n        this.visitList(varDeclList.declarations);\n        break;\n      case ts.SyntaxKind.VariableDeclaration:\n        let varDecl = <ts.VariableDeclaration>node;\n        this.visitVariableDeclarationType(varDecl);\n        this.visit(varDecl.name);\n        if (varDecl.initializer) {\n          this.emit('=');\n          this.visit(varDecl.initializer);\n        }\n        break;\n\n      case ts.SyntaxKind.ClassDeclaration:\n        let classDecl = <ts.ClassDeclaration>node;\n        if (classDecl.modifiers && (classDecl.modifiers.flags & ts.NodeFlags.Abstract)) {\n          this.visitClassLike('abstract class', classDecl);\n        } else {\n          this.visitClassLike('class', classDecl);\n        }\n        break;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        let ifDecl = <ts.InterfaceDeclaration>node;\n        // Function type interface in an interface with a single declaration\n        // of a call signature (http://goo.gl/ROC5jN).\n        if (ifDecl.members.length === 1 && ifDecl.members[0].kind === ts.SyntaxKind.CallSignature) {\n          let member = <ts.CallSignatureDeclaration>ifDecl.members[0];\n          this.visitFunctionTypedefInterface(ifDecl.name.text, member, ifDecl.typeParameters);\n        } else {\n          this.visitClassLike('abstract class', ifDecl);\n        }\n        break;\n      case ts.SyntaxKind.HeritageClause:\n        let heritageClause = <ts.HeritageClause>node;\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword &&\n            heritageClause.parent.kind !== ts.SyntaxKind.InterfaceDeclaration) {\n          this.emit('extends');\n        } else {\n          this.emit('implements');\n        }\n        // Can only have one member for extends clauses.\n        this.visitList(heritageClause.types);\n        break;\n      case ts.SyntaxKind.ExpressionWithTypeArguments:\n        let exprWithTypeArgs = <ts.ExpressionWithTypeArguments>node;\n        this.visit(exprWithTypeArgs.expression);\n        this.maybeVisitTypeArguments(exprWithTypeArgs);\n        break;\n      case ts.SyntaxKind.EnumDeclaration:\n        let decl = <ts.EnumDeclaration>node;\n        // The only legal modifier for an enum decl is const.\n        let isConst = decl.modifiers && (decl.modifiers.flags & ts.NodeFlags.Const);\n        if (isConst) {\n          this.reportError(node, 'const enums are not supported');\n        }\n        this.emit('enum');\n        this.fc.visitTypeName(decl.name);\n        this.emit('{');\n        // Enums can be empty in TS ...\n        if (decl.members.length === 0) {\n          // ... but not in Dart.\n          this.reportError(node, 'empty enums are not supported');\n        }\n        this.visitList(decl.members);\n        this.emit('}');\n        break;\n      case ts.SyntaxKind.EnumMember:\n        let member = <ts.EnumMember>node;\n        this.visit(member.name);\n        if (member.initializer) {\n          this.reportError(node, 'enum initializers are not supported');\n        }\n        break;\n      case ts.SyntaxKind.Constructor:\n        let ctorDecl = <ts.ConstructorDeclaration>node;\n        // Find containing class name.\n        let className: ts.Identifier;\n        for (let parent = ctorDecl.parent; parent; parent = parent.parent) {\n          if (parent.kind === ts.SyntaxKind.ClassDeclaration) {\n            className = (<ts.ClassDeclaration>parent).name;\n            break;\n          }\n        }\n        if (!className) this.reportError(ctorDecl, 'cannot find outer class node');\n        this.visitDeclarationMetadata(ctorDecl);\n        if (this.fc.isConstClass(<base.ClassLike>ctorDecl.parent)) {\n          this.emit('const');\n        }\n        this.visit(className);\n        this.visitParameters(ctorDecl.parameters);\n        this.visit(ctorDecl.body);\n        break;\n      case ts.SyntaxKind.PropertyDeclaration:\n        this.visitProperty(<ts.PropertyDeclaration>node);\n        break;\n      case ts.SyntaxKind.SemicolonClassElement:\n        // No-op, don't emit useless declarations.\n        break;\n      case ts.SyntaxKind.MethodDeclaration:\n        this.visitDeclarationMetadata(<ts.MethodDeclaration>node);\n        this.visitFunctionLike(<ts.MethodDeclaration>node);\n        break;\n      case ts.SyntaxKind.GetAccessor:\n        this.visitDeclarationMetadata(<ts.MethodDeclaration>node);\n        this.visitFunctionLike(<ts.AccessorDeclaration>node, 'get');\n        break;\n      case ts.SyntaxKind.SetAccessor:\n        this.visitDeclarationMetadata(<ts.MethodDeclaration>node);\n        this.visitFunctionLike(<ts.AccessorDeclaration>node, 'set');\n        break;\n      case ts.SyntaxKind.FunctionDeclaration:\n        let funcDecl = <ts.FunctionDeclaration>node;\n        this.visitDecorators(funcDecl.decorators);\n        this.visitFunctionLike(funcDecl);\n        break;\n      case ts.SyntaxKind.ArrowFunction:\n        let arrowFunc = <ts.FunctionExpression>node;\n        // Dart only allows expressions following the fat arrow operator.\n        // If the body is a block, we have to drop the fat arrow and emit an\n        // anonymous function instead.\n        if (arrowFunc.body.kind === ts.SyntaxKind.Block) {\n          this.visitFunctionLike(arrowFunc);\n        } else {\n          this.visitParameters(arrowFunc.parameters);\n          this.emit('=>');\n          this.visit(arrowFunc.body);\n        }\n        break;\n      case ts.SyntaxKind.FunctionExpression:\n        let funcExpr = <ts.FunctionExpression>node;\n        this.visitFunctionLike(funcExpr);\n        break;\n      case ts.SyntaxKind.PropertySignature:\n        let propSig = <ts.PropertyDeclaration>node;\n        this.visitProperty(propSig);\n        break;\n      case ts.SyntaxKind.MethodSignature:\n        let methodSignatureDecl = <ts.FunctionLikeDeclaration>node;\n        this.visitEachIfPresent(methodSignatureDecl.modifiers);\n        this.visitFunctionLike(methodSignatureDecl);\n        break;\n      case ts.SyntaxKind.Parameter:\n        let paramDecl = <ts.ParameterDeclaration>node;\n        // Property parameters will have an explicit property declaration, so we just\n        // need the dart assignment shorthand to reference the property.\n        if (this.hasFlag(paramDecl.modifiers, ts.NodeFlags.Public) ||\n            this.hasFlag(paramDecl.modifiers, ts.NodeFlags.Private) ||\n            this.hasFlag(paramDecl.modifiers, ts.NodeFlags.Protected)) {\n          this.visitDeclarationMetadata(paramDecl);\n          this.emit('this .');\n          this.visit(paramDecl.name);\n          if (paramDecl.initializer) {\n            this.emit('=');\n            this.visit(paramDecl.initializer);\n          }\n          break;\n        }\n        if (paramDecl.dotDotDotToken) this.reportError(node, 'rest parameters are unsupported');\n        if (paramDecl.name.kind === ts.SyntaxKind.ObjectBindingPattern) {\n          this.visitNamedParameter(paramDecl);\n          break;\n        }\n        this.visitDecorators(paramDecl.decorators);\n\n        if (paramDecl.type && paramDecl.type.kind === ts.SyntaxKind.FunctionType) {\n          // Dart uses \"returnType paramName ( parameters )\" syntax.\n          let fnType = <ts.FunctionOrConstructorTypeNode>paramDecl.type;\n          let hasRestParameter = fnType.parameters.some(p => !!p.dotDotDotToken);\n          if (hasRestParameter) {\n            // Dart does not support rest parameters/varargs, degenerate to just \"Function\".\n            this.emit('Function');\n            this.visit(paramDecl.name);\n          } else {\n            this.visit(fnType.type);\n            this.visit(paramDecl.name);\n            this.visitParameters(fnType.parameters);\n          }\n        } else {\n          if (paramDecl.type) this.visit(paramDecl.type);\n          this.visit(paramDecl.name);\n        }\n        if (paramDecl.initializer) {\n          this.emit('=');\n          this.visit(paramDecl.initializer);\n        }\n        break;\n      case ts.SyntaxKind.StaticKeyword:\n        this.emit('static');\n        break;\n      case ts.SyntaxKind.AbstractKeyword:\n        // Abstract methods in Dart simply lack implementation,\n        // and don't use the 'abstract' modifier\n        // Abstract classes are handled in `case ts.SyntaxKind.ClassDeclaration` above.\n        break;\n      case ts.SyntaxKind.PrivateKeyword:\n          this.emit('/*private*/');\n        // no-op, handled through '_' naming convention in Dart.\n        break;\n      case ts.SyntaxKind.PublicKeyword:\n          this.emit('/*public*/');\n        break;\n      case ts.SyntaxKind.ProtectedKeyword:\n          this.emit('/*protected*/');\n          break;\n      case ts.SyntaxKind.AwaitExpression:\n        // Handled in `visitDeclarationMetadata` below.\n        this.emit('await');\n        this.visit((<any>node).expression);\n        break;\n      case ts.SyntaxKind.AsyncKeyword:\n        (<any>this).__async = true;\n        break;\n      case ts.SyntaxKind.ObjectBindingPattern:\n          this.emit('/*');\n          const n: any = node;\n          let first: boolean = true;\n          for (var e of n.elements) {\n              if (!first) {\n                  this.emit(',');\n              }\n              first = false;\n              this.emit(e.name.text);\n          }\n          this.emit('*/');\n          break;\n\n\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  private visitVariableDeclarationType(varDecl: ts.VariableDeclaration) {\n    /* Note: VariableDeclarationList can only occur as part of a for loop. This helper method\n     * is meant for processing for-loop variable declaration types only.\n     *\n     * In Dart, all variables in a variable declaration list must have the same type. Since\n     * we are doing syntax directed translation, we cannot reliably determine if distinct\n     * variables are declared with the same type or not. Hence we support the following cases:\n     *\n     * - A variable declaration list with a single variable can be explicitly typed.\n     * - When more than one variable is in the list, all must be implicitly typed.\n     */\n    let firstDecl = varDecl.parent.declarations[0];\n    let msg = 'Variables in a declaration list of more than one variable cannot by typed';\n    let isFinal = this.hasFlag(varDecl.parent, ts.NodeFlags.Const);\n    let isConst = false;\n    if (isFinal && varDecl.initializer) {\n      // \"const\" in TypeScript/ES6 corresponds to \"final\" in Dart, i.e. reference constness.\n      // If a \"const\" variable is immediately initialized to a CONST_EXPR(), special case it to be\n      // a deeply const constant, and generate \"const ...\".\n      isConst = varDecl.initializer.kind === ts.SyntaxKind.StringLiteral ||\n          varDecl.initializer.kind === ts.SyntaxKind.NumericLiteral ||\n          this.fc.isConstExpr(varDecl.initializer);\n    }\n    if (firstDecl === varDecl) {\n      if (isConst) {\n        this.emit('const');\n      } else if (isFinal) {\n        this.emit('final');\n      }\n      if (!varDecl.type) {\n        if (!isFinal) this.emit('var');\n      } else if (varDecl.parent.declarations.length > 1) {\n        this.reportError(varDecl, msg);\n      } else {\n        this.visit(varDecl.type);\n      }\n    } else if (varDecl.type) {\n      this.reportError(varDecl, msg);\n    }\n  }\n\n  private visitFunctionLike(fn: ts.FunctionLikeDeclaration, accessor?: string) {\n    this.fc.pushTypeParameterNames(fn);\n    try {\n      if (fn.type) {\n        if (fn.kind === ts.SyntaxKind.ArrowFunction ||\n            fn.kind === ts.SyntaxKind.FunctionExpression) {\n          // The return type is silently dropped for function expressions (including arrow\n          // functions), it is not supported in Dart.\n          this.emit('/*');\n          this.visit(fn.type);\n          this.emit('*/');\n        } else {\n          this.visit(fn.type);\n        }\n      }\n      if (accessor) this.emit(accessor);\n      if (fn.name) this.visit(fn.name);\n      if (fn.typeParameters) {\n        this.emit('/*<');\n        // Emit the names literally instead of visiting, otherwise they will be replaced with the\n        // comment hack themselves.\n        this.emit(fn.typeParameters.map(p => base.ident(p.name)).join(', '));\n        this.emit('>*/');\n      }\n      // Dart does not even allow the parens of an empty param list on getter\n      if (accessor !== 'get') {\n        this.visitParameters(fn.parameters);\n      } else {\n        if (fn.parameters && fn.parameters.length > 0) {\n          this.reportError(fn, 'getter should not accept parameters');\n        }\n      }\n      if (fn.body) {\n        this.visit(fn.body);\n      } else {\n        this.emit(';');\n      }\n    } finally {\n      this.fc.popTypeParameterNames(fn);\n    }\n  }\n\n  private visitParameters(parameters: ts.ParameterDeclaration[]) {\n    this.emit('(');\n    let firstInitParamIdx = 0;\n    for (; firstInitParamIdx < parameters.length; firstInitParamIdx++) {\n      // ObjectBindingPatterns are handled within the parameter visit.\n      let isOpt =\n          parameters[firstInitParamIdx].initializer || parameters[firstInitParamIdx].questionToken;\n      if (isOpt && parameters[firstInitParamIdx].name.kind !== ts.SyntaxKind.ObjectBindingPattern) {\n        break;\n      }\n    }\n\n    if (firstInitParamIdx !== 0) {\n      let requiredParams = parameters.slice(0, firstInitParamIdx);\n      this.visitList(requiredParams);\n    }\n\n    if (firstInitParamIdx !== parameters.length) {\n      if (firstInitParamIdx !== 0) this.emit(',');\n      let positionalOptional = parameters.slice(firstInitParamIdx, parameters.length);\n      this.emit('[');\n      this.visitList(positionalOptional);\n      this.emit(']');\n    }\n\n    this.emit(')');\n    if ((<any>this)['__async']) {\n      this.emit('async');\n      (<any>this)['__async'] = false;\n    }\n  }\n\n  /**\n   * Visit a property declaration.\n   * In the special case of property parameters in a constructor, we also allow a parameter to be\n   * emitted as a property.\n   */\n  private visitProperty(decl: ts.PropertyDeclaration|ts.ParameterDeclaration, isParameter = false) {\n    if (!isParameter) this.visitDeclarationMetadata(decl);\n    let containingClass = <base.ClassLike>(isParameter ? decl.parent.parent : decl.parent);\n    let isConstField =\n        this.fc.hasConstComment(decl) || this.hasAnnotation(decl.decorators, 'CONST');\n    let hasConstCtor = this.fc.isConstClass(containingClass);\n    if (isConstField) {\n      // const implies final\n      this.emit('const');\n    } else {\n      if (hasConstCtor) {\n        this.emit('final');\n      }\n    }\n    if (decl.type) {\n      this.visit(decl.type);\n    } else if (!isConstField && !hasConstCtor) {\n      this.emit('var');\n    }\n    this.visit(decl.name);\n    if (decl.initializer && !isParameter) {\n      this.emit('=');\n      this.visit(decl.initializer);\n    }\n    this.emit(';');\n  }\n\n  private visitClassLike(keyword: string, decl: base.ClassLike) {\n    this.visitDecorators(decl.decorators);\n    this.emit(keyword);\n    this.fc.visitTypeName(decl.name);\n    if (decl.typeParameters) {\n      this.emit('<');\n      this.visitList(decl.typeParameters);\n      this.emit('>');\n    }\n    this.visitEachIfPresent(decl.heritageClauses);\n    this.emit('{');\n\n    // Synthesize explicit properties for ctor with 'property parameters'\n    let synthesizePropertyParam = (param: ts.ParameterDeclaration) => {\n      if (this.hasFlag(param.modifiers, ts.NodeFlags.Public) ||\n          this.hasFlag(param.modifiers, ts.NodeFlags.Private) ||\n          this.hasFlag(param.modifiers, ts.NodeFlags.Protected)) {\n        // TODO: we should enforce the underscore prefix on privates\n        this.visitProperty(param, true);\n      }\n    };\n    (<ts.NodeArray<ts.Declaration>>decl.members)\n        .filter((m) => m.kind === ts.SyntaxKind.Constructor)\n        .forEach(\n            (ctor) =>\n                (<ts.ConstructorDeclaration>ctor).parameters.forEach(synthesizePropertyParam));\n    this.visitEachIfPresent(decl.members);\n\n    // Generate a constructor to host the const modifier, if needed\n    if (this.fc.isConstClass(decl) &&\n        !(<ts.NodeArray<ts.Declaration>>decl.members)\n             .some((m) => m.kind === ts.SyntaxKind.Constructor)) {\n      this.emit('const');\n      this.fc.visitTypeName(decl.name);\n      this.emit('();');\n    }\n    this.emit('}');\n  }\n\n  private visitDecorators(decorators: ts.NodeArray<ts.Decorator>) {\n    if (!decorators) return;\n\n    decorators.forEach((d) => {\n      // Special case @CONST\n      let name = base.ident(d.expression);\n      if (!name && d.expression.kind === ts.SyntaxKind.CallExpression) {\n        // Unwrap @CONST()\n        let callExpr = (<ts.CallExpression>d.expression);\n        name = base.ident(callExpr.expression);\n      }\n      // Make sure these match IGNORED_ANNOTATIONS below.\n      if (name === 'CONST') {\n        // Ignore @CONST - it is handled above in visitClassLike.\n        return;\n      }\n      this.emit('@');\n      this.visit(d.expression);\n    });\n  }\n\n  private visitDeclarationMetadata(decl: ts.Declaration) {\n    this.visitDecorators(decl.decorators);\n    this.visitEachIfPresent(decl.modifiers);\n\n    if (this.hasFlag(decl.modifiers, ts.NodeFlags.Protected)) {\n      // this.reportError(decl, 'protected declarations are unsupported');\n      return;\n    }\n    if (!this.enforceUnderscoreConventions) return;\n    // Early return in case this is a decl with no name, such as a constructor\n    if (!decl.name) return;\n    let name = base.ident(decl.name);\n    if (!name) return;\n    let isPrivate = this.hasFlag(decl.modifiers, ts.NodeFlags.Private);\n    let matchesPrivate = !!name.match(/^_/);\n    if (isPrivate && !matchesPrivate) {\n      this.reportError(decl, 'private members must be prefixed with \"_\"');\n    }\n    if (!isPrivate && matchesPrivate) {\n      this.reportError(decl, 'public members must not be prefixed with \"_\"');\n    }\n  }\n\n  private visitNamedParameter(paramDecl: ts.ParameterDeclaration) {\n    this.visitDecorators(paramDecl.decorators);\n    let bp = <ts.BindingPattern>paramDecl.name;\n    let propertyTypes = this.fc.resolvePropertyTypes(paramDecl.type);\n    let initMap = this.getInitializers(paramDecl);\n    this.emit('{');\n    for (let i = 0; i < bp.elements.length; i++) {\n      let elem = bp.elements[i];\n      let propDecl = propertyTypes[base.ident(elem.name)];\n      if (propDecl && propDecl.type) this.visit(propDecl.type);\n      this.visit(elem.name);\n      if (elem.initializer && initMap[base.ident(elem.name)]) {\n        this.reportError(elem, 'cannot have both an inner and outer initializer');\n      }\n      let init = elem.initializer || initMap[base.ident(elem.name)];\n      if (init) {\n        this.emit(':');\n        this.visit(init);\n      }\n      if (i + 1 < bp.elements.length) this.emit(',');\n    }\n    this.emit('}');\n  }\n\n  private getInitializers(paramDecl: ts.ParameterDeclaration) {\n    let res: ts.Map<ts.Expression> = {};\n    if (!paramDecl.initializer) return res;\n    if (paramDecl.initializer.kind !== ts.SyntaxKind.ObjectLiteralExpression) {\n      this.reportError(paramDecl, 'initializers for named parameters must be object literals');\n      return res;\n    }\n    for (let i of (<ts.ObjectLiteralExpression>paramDecl.initializer).properties) {\n      if (i.kind !== ts.SyntaxKind.PropertyAssignment) {\n        this.reportError(i, 'named parameter initializers must be properties, got ' + i.kind);\n        continue;\n      }\n      let ole = <ts.PropertyAssignment>i;\n      res[base.ident(ole.name)] = ole.initializer;\n    }\n    return res;\n  }\n\n  /**\n   * Handles a function typedef-like interface, i.e. an interface that only declares a single\n   * call signature, by translating to a Dart `typedef`.\n   */\n  private visitFunctionTypedefInterface(\n      name: string, signature: ts.CallSignatureDeclaration,\n      typeParameters: ts.NodeArray<ts.TypeParameterDeclaration>) {\n    this.emit('typedef');\n    if (signature.type) {\n      this.visit(signature.type);\n    }\n    this.emit(name);\n    if (typeParameters) {\n      this.emit('<');\n      this.visitList(typeParameters);\n      this.emit('>');\n    }\n    this.visitParameters(signature.parameters);\n    this.emit(';');\n  }\n}\n"]}