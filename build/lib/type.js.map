{"version":3,"sources":["type.ts"],"names":[],"mappings":"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","file":"type.js","sourcesContent":["import * as ts from 'typescript';\n\nimport * as base from './base';\nimport {FacadeConverter} from './facade_converter';\nimport {Transpiler} from './main';\n\nexport default class TypeTranspiler extends base.TranspilerBase {\n  constructor(tr: Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.TypeLiteral:\n        let indexType = this.maybeDestructureIndexType(<ts.TypeLiteralNode>node);\n        if (indexType) {\n          // This is effectively a Map.\n          this.emit('Map <');\n          this.visit(indexType[0]);\n          this.emit(',');\n          this.visit(indexType[1]);\n          this.emit('>');\n        } else {\n          // Dart doesn't support other type literals.\n          this.emit('dynamic');\n        }\n        break;\n      case ts.SyntaxKind.UnionType:\n        this.emit('dynamic /*');\n        this.visitList((<ts.UnionTypeNode>node).types, '|');\n        this.emit('*/');\n        break;\n      case ts.SyntaxKind.TypeReference:\n        let typeRef = <ts.TypeReferenceNode>node;\n        this.fc.visitTypeName(typeRef.typeName);\n        this.maybeVisitTypeArguments(typeRef);\n        break;\n      case ts.SyntaxKind.TypeAssertionExpression:\n        let typeAssertExpr = <ts.TypeAssertion>node;\n        if (this.isReifiedTypeLiteral(typeAssertExpr)) {\n          this.visit(typeAssertExpr.expression);\n          break;  // type is handled by the container literal itself.\n        }\n        this.emit('(');\n        this.visit(typeAssertExpr.expression);\n        this.emit('as');\n        this.visit(typeAssertExpr.type);\n        this.emit(')');\n        break;\n      case ts.SyntaxKind.TypeParameter:\n        let typeParam = <ts.TypeParameterDeclaration>node;\n        this.visit(typeParam.name);\n        if (typeParam.constraint) {\n          this.emit('extends');\n          this.visit(typeParam.constraint);\n        }\n        break;\n      case ts.SyntaxKind.ArrayType:\n        this.emit('List');\n        this.emit('<');\n        this.visit((<ts.ArrayTypeNode>node).elementType);\n        this.emit('>');\n        break;\n      case ts.SyntaxKind.FunctionType:\n        this.emit('dynamic /*');\n        this.emit(node.getText());\n        this.emit('*/');\n        break;\n      case ts.SyntaxKind.QualifiedName:\n        let first = <ts.QualifiedName>node;\n        this.visit(first.left);\n        this.emit('.');\n        this.visit(first.right);\n        break;\n      case ts.SyntaxKind.Identifier:\n        let ident = <ts.Identifier>node;\n        this.fc.visitTypeName(ident);\n        break;\n      case ts.SyntaxKind.NumberKeyword:\n        this.emit('num');\n        break;\n      case ts.SyntaxKind.StringKeyword:\n        this.emit('String');\n        break;\n      case ts.SyntaxKind.VoidKeyword:\n        this.emit('void');\n        break;\n      case ts.SyntaxKind.BooleanKeyword:\n        this.emit('bool');\n        break;\n      case ts.SyntaxKind.AnyKeyword:\n        this.emit('dynamic');\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  isReifiedTypeLiteral(node: ts.TypeAssertion): boolean {\n    if (node.expression.kind === ts.SyntaxKind.ArrayLiteralExpression &&\n        node.type.kind === ts.SyntaxKind.ArrayType) {\n      return true;\n    } else if (\n        node.expression.kind === ts.SyntaxKind.ObjectLiteralExpression &&\n        node.type.kind === ts.SyntaxKind.TypeLiteral) {\n      return true;\n    }\n    return false;\n  }\n}\n"]}