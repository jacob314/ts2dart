{"version":3,"sources":["expression.ts"],"names":[],"mappings":"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","file":"expression.js","sourcesContent":["import * as ts from 'typescript';\n\nimport * as base from './base';\nimport {FacadeConverter} from './facade_converter';\nimport {Transpiler} from './main';\n\nexport default class ExpressionTranspiler extends base.TranspilerBase {\n  constructor(tr: Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.BinaryExpression:\n        let binExpr = <ts.BinaryExpression>node;\n        let operatorKind = binExpr.operatorToken.kind;\n        let tokenStr = ts.tokenToString(operatorKind);\n        switch (operatorKind) {\n          case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n            // this.emit('identical (');\n            this.visit(binExpr.left);\n\n            if (operatorKind === ts.SyntaxKind.ExclamationEqualsEqualsToken) {\n              this.emit('!=');\n            } else {\n              this.emit('==');\n            }\n            this.visit(binExpr.right);\n            // this.emit(')');\n            break;\n          case ts.SyntaxKind.CaretToken:\n          case ts.SyntaxKind.BarToken:\n          case ts.SyntaxKind.AmpersandToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanToken:\n          case ts.SyntaxKind.LessThanLessThanToken:\n          case ts.SyntaxKind.CaretEqualsToken:\n          case ts.SyntaxKind.BarEqualsToken:\n          case ts.SyntaxKind.AmpersandEqualsToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n          case ts.SyntaxKind.LessThanLessThanEqualsToken:\n            // In Dart, the bitwise operators are only available on int, so the number types ts2dart\n            // deals with have to be converted to int explicitly to match JS's semantics in Dart.\n            if (tokenStr[tokenStr.length - 1] === '=') {\n              // For assignments, strip the trailing `=` sign to emit just the operator itself.\n              this.visit(binExpr.left);\n              this.emit('=');\n              this.visitAndWrapAsInt(binExpr.left);\n              this.emit(tokenStr.slice(0, -1));\n            } else {\n              // normal case (LHS [op])\n              this.visitAndWrapAsInt(binExpr.left);\n              this.emit(tokenStr);\n            }\n            this.visitAndWrapAsInt(binExpr.right);\n            break;\n          case ts.SyntaxKind.InKeyword:\n            this.reportError(node, 'in operator is unsupported');\n            break;\n          case ts.SyntaxKind.InstanceOfKeyword:\n            this.visit(binExpr.left);\n            this.emit('is');\n            this.fc.visitTypeName(<ts.Identifier>binExpr.right);\n            break;\n          default:\n            this.visit(binExpr.left);\n            this.emit(tokenStr);\n            this.visit(binExpr.right);\n            break;\n        }\n        break;\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        let prefixUnary = <ts.PrefixUnaryExpression>node;\n        let operator = ts.tokenToString(prefixUnary.operator);\n        this.emit(operator);\n\n        if (prefixUnary.operator === ts.SyntaxKind.TildeToken) {\n          this.visitAndWrapAsInt(prefixUnary.operand);\n        } else {\n          this.visit(prefixUnary.operand);\n        }\n        break;\n      case ts.SyntaxKind.PostfixUnaryExpression:\n        let postfixUnary = <ts.PostfixUnaryExpression>node;\n        this.visit(postfixUnary.operand);\n        this.emit(ts.tokenToString(postfixUnary.operator));\n        break;\n      case ts.SyntaxKind.ConditionalExpression:\n        let conditional = <ts.ConditionalExpression>node;\n        this.visit(conditional.condition);\n        this.emit('?');\n        this.visit(conditional.whenTrue);\n        this.emit(':');\n        this.visit(conditional.whenFalse);\n        break;\n      case ts.SyntaxKind.DeleteExpression:\n        this.emit('/*delete*/');\n        // this.reportError(node, 'delete operator is unsupported');\n        break;\n      case ts.SyntaxKind.VoidExpression:\n        this.emit('/*void*/');\n        // this.reportError(node, 'void operator is unsupported');\n        break;\n      case ts.SyntaxKind.TypeOfExpression:\n        this.emit('/*typeof*/');\n        this.visit((<any>node).expression);\n        // this.reportError(node, 'typeof operator is unsupported');\n        break;\n\n      case ts.SyntaxKind.ParenthesizedExpression:\n        let parenExpr = <ts.ParenthesizedExpression>node;\n        this.emit('(');\n        this.visit(parenExpr.expression);\n        this.emit(')');\n        break;\n\n      case ts.SyntaxKind.PropertyAccessExpression:\n        let propAccess = <ts.PropertyAccessExpression>node;\n        if (propAccess.name.text === 'stack' &&\n            this.hasAncestor(propAccess, ts.SyntaxKind.CatchClause)) {\n          // Handle `e.stack` accesses in catch clauses by mangling to `e_stack`.\n          // FIXME: Use type checker/FacadeConverter to make sure this is actually Error.stack.\n          this.visit(propAccess.expression);\n          this.emitNoSpace('_stack');\n        } else {\n          if (this.fc.handlePropertyAccess(propAccess)) break;\n          this.visit(propAccess.expression);\n          this.emit('.');\n          this.visit(propAccess.name);\n        }\n        break;\n      case ts.SyntaxKind.ElementAccessExpression:\n        let elemAccess = <ts.ElementAccessExpression>node;\n        this.visit(elemAccess.expression);\n        this.emit('[');\n        this.visit(elemAccess.argumentExpression);\n        this.emit(']');\n        break;\n\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  visitAndWrapAsInt(n: ts.Expression) {\n    let lhsIsHexLit = n.kind === ts.SyntaxKind.NumericLiteral;\n    if (lhsIsHexLit) {\n      this.visit(n);\n      return;\n    }\n    this.emit('(');\n    this.visit(n);\n    this.emit('as int)');\n  }\n}\n"]}